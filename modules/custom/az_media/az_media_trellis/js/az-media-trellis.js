/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
(function azMediaTrellisIife(Drupal, drupalSettings) {
  /**
   * Intercepts attempts by the Trellis (FormAssembly) embed script to inject
   * its default stylesheet (form-assembly.css). This must run BEFORE the
   * remote script is appended to the DOM, so we install it at the top of the
   * behavior execution path and only once.
   */
  function installCssBlockerOnce() {
    if (window.__azTrellisCssBlockerInstalled) return;
    window.__azTrellisCssBlockerInstalled = true;
    // List of stylesheet URL patterns to block (expanded from single file
    // to all Trellis layout/theme CSS we intend to replace with Bootstrap).
    const BLOCK_PATTERNS = [
      /design\.trellis\.arizona\.edu\/css\/form-assembly\.css/i,
      /forms-a\.trellis\.arizona\.edu\/dist\/form-builder\//i,
      /forms-a\.trellis\.arizona\.edu\/uploads\/themes\//i,
      /forms-a\.trellis\.arizona\.edu\/wForms\/3\.11\/css\//i,
      /forms-a\.trellis\.arizona\.edu\/wForms\/3\.11\/js\/css/i // safety catch
    ];

    function isBlockedStylesheet(node) {
      if (!node || node.tagName !== 'LINK' || node.rel !== 'stylesheet') return false;
      return BLOCK_PATTERNS.some(rx => rx.test(node.href));
    }

    function interceptorFactory(original) {
      return function(node) {
        try {
          if (isBlockedStylesheet(node)) {
            return node; // silently drop
          }
        } catch (e) { /* ignore */ }
        return original.call(this, node);
      };
    }

    function interceptorBeforeFactory(original) {
      return function(newNode, refNode) {
        try {
          if (isBlockedStylesheet(newNode)) {
            return newNode; // drop
          }
        } catch (e) { /* ignore */ }
        return original.call(this, newNode, refNode);
      };
    }

    const protoDoc = Document.prototype;
    const protoHead = HTMLHeadElement.prototype;
    if (!protoDoc.__azPatchedAppendChild) {
      protoDoc.__azPatchedAppendChild = true;
      protoDoc.appendChild = interceptorFactory(protoDoc.appendChild);
    }
    if (!protoHead.__azPatchedAppendChild) {
      protoHead.__azPatchedAppendChild = true;
      protoHead.appendChild = interceptorFactory(protoHead.appendChild);
    }
    if (!protoHead.__azPatchedInsertBefore) {
      protoHead.__azPatchedInsertBefore = true;
      protoHead.insertBefore = interceptorBeforeFactory(protoHead.insertBefore);
    }

    // Mutation observer as a safety net for any <link> nodes inserted through
    // means other than the patched methods.
    const headObserver = new MutationObserver(muts => {
      muts.forEach(m => {
        m.addedNodes.forEach(n => {
          if (isBlockedStylesheet(n) && n.parentNode) {
            n.parentNode.removeChild(n);
          }
        });
      });
    });
    headObserver.observe(document.head, { childList: true });
  }

  /**
   * Dynamically loads the Trellis embed script after blockers are in place.
   * @param {HTMLElement} el Container element with data-trellis-embed-src.
   */
  function loadTrellisScript(el) {
    const url = el.getAttribute('data-trellis-embed-src');
    // If the formatter already injected the script, respect that.
    if (!url || el.getAttribute('data-trellis-script-loaded') || el.getAttribute('data-trellis-script-preloaded')) return;
    el.setAttribute('data-trellis-script-loaded', '1');
    const script = document.createElement('script');
    script.src = url;
    script.defer = true;
    script.type = 'text/javascript';
    // Provide the original quick-publish target id for potential script usage.
    if (el.id) {
      script.setAttribute('data-qp-target-id', el.id);
    }
    document.head.appendChild(script);
  }
  function TrellisFormHandler(container, queryParams, editing) {
    this.container = container;
    this.queryParams = queryParams;
    this.editing = editing;
    this.processed = false;
    this.sanitized = false;
    this.spinnerInserted = false;
    this.spinnerRemoved = false;
  }
  TrellisFormHandler.prototype.init = function init() {
    this.insertSpinner();
    this.setupContentObserver();
    if (this.container.children.length > 0) {
      this.processForm();
    }
  };
  TrellisFormHandler.prototype.setupContentObserver = function setupContentObserver() {
    if (this.processed) return;
    const observer = new MutationObserver(() => {
      if (!this.processed && this.container.children.length > 0) {
        this.processForm();
        observer.disconnect();
      }
    });
    observer.observe(this.container, {
      childList: true,
      subtree: true
    });
  };
  TrellisFormHandler.prototype.processForm = function processForm() {
    if (this.processed) return;
    this.processed = true;
    if (this.editing) {
      this.setupEditingMode();
    }
    this.prefillFields();
    this.sanitizeAndRetheme();
    this.observeDynamicMutations();
    this.removeSpinner();
  };
  /**
   * Remove unwanted styling (external or inline) and apply Arizona Bootstrap classes.
   */
  TrellisFormHandler.prototype.sanitizeAndRetheme = function sanitizeAndRetheme() {
    if (this.sanitized) return;
    this.sanitized = true;
    const root = this.container;

    // 1. Remove inline style attributes.
    root.querySelectorAll('[style]').forEach(el => {
      el.removeAttribute('style');
    });

    // 2. Remove <style> tags inside container & any code-section style blocks.
    root.querySelectorAll('style').forEach(s => s.remove());

    // 2b. Remove any <br> directly between label and input.
    root.querySelectorAll('.oneField br').forEach(br => {
      const prev = br.previousElementSibling; const next = br.nextElementSibling;
      if (prev && next && (next.matches('.inputWrapper') || next.querySelector('input,textarea,select'))) br.remove();
    });

  // 3. Basic class remapping for form controls (additive: we do NOT
  // remove original classes to avoid breaking remote script behaviors).
    const addClass = (el, cls) => { if (!el.classList.contains(cls)) el.classList.add(...cls.split(/\s+/)); };

    root.querySelectorAll('input, select, textarea, button').forEach(el => {
      const tag = el.tagName.toLowerCase();
      const type = (el.getAttribute('type') || '').toLowerCase();
      if (tag === 'input') {
        if (['text','email','tel','url','number','search','password','date','datetime-local','time'].includes(type)) {
          addClass(el, 'form-control');
        }
        else if (['checkbox','radio'].includes(type)) {
          addClass(el, 'form-check-input');
          // Try to find its label (sibling or parent) and style appropriately.
          let label = el.closest('label');
          if (!label) {
            // Try next sibling label with for attr.
            const id = el.id;
            if (id) {
              label = root.querySelector(`label[for="${CSS.escape(id)}"]`);
            }
          }
            if (label) addClass(label, 'form-check-label');
            // Ensure wrapper has form-check.
            const wrapper = label ? label.parentElement : el.parentElement;
            if (wrapper && !wrapper.classList.contains('form-check')) wrapper.classList.add('form-check');
        }
        else if (type === 'submit') {
          addClass(el, 'btn btn-primary');
        }
      }
      else if (tag === 'select') {
        addClass(el, 'form-select');
      }
      else if (tag === 'textarea') {
        addClass(el, 'form-control');
      }
      else if (tag === 'button') {
        addClass(el, 'btn btn-primary');
      }
    });

    // 4. Wrap orphaned checkboxes/radios lacking form-check wrapper.
    root.querySelectorAll('input.form-check-input').forEach(input => {
      if (!input.closest('.form-check')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'form-check';
        input.parentNode.insertBefore(wrapper, input);
        wrapper.appendChild(input);
        // Move label if immediately following.
        const next = input.nextElementSibling;
        if (next && next.tagName === 'LABEL' && !next.classList.contains('form-check-label')) {
          next.classList.add('form-check-label');
          wrapper.appendChild(next);
        }
      }
    });

    // 5. Add form-group spacing to direct field wrappers if we can guess them.
    // 5. Add form-group spacing & form-label classes.
    root.querySelectorAll('.oneField').forEach(of => {
      if (!of.classList.contains('mb-3')) of.classList.add('mb-3');
      const label = of.querySelector('label');
      if (label && !label.classList.contains('form-label') && !label.classList.contains('form-check-label')) {
        label.classList.add('form-label');
      }
    });

    // 6. Convert read-only descriptive textareas (campaign info) to plaintext style.
    root.querySelectorAll('textarea[readonly]').forEach(ta => {
      if (!ta.value || ta.value.length > 160) return; // heuristic skip large bodies
      ta.classList.add('form-control-plaintext');
    });

    // 7. Remove Trellis privacy statement / footer (user requested strip).
    // Target anchor containing 'privacy-statement' and remove closest footer wrappers.
    const privacyLinks = root.querySelectorAll('a[href*="privacy-statement"]');
    privacyLinks.forEach(a => {
      const footer = a.closest('.wFormFooter');
      if (footer) footer.remove();
      // Also remove any trailing sibling .supportInfo paragraphs with only that link.
      const support = a.closest('p.supportInfo');
      if (support && support.parentNode) {
        // If after removing link paragraph is empty or just <br>, remove it.
        if (support.textContent.trim() === '' || support.querySelectorAll('a').length === 0) {
          support.remove();
        }
      }
    });
  };

  /**
   * Observe subsequent dynamic DOM mutations (some form scripts progressively enhance fields).
   */
  TrellisFormHandler.prototype.observeDynamicMutations = function observeDynamicMutations() {
    const observer = new MutationObserver(mutations => {
      let needsResanitize = false;
      let hasFormContent = false;
      mutations.forEach(m => {
        m.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            if (node.hasAttribute && node.hasAttribute('style')) needsResanitize = true;
            if (node.querySelector && node.querySelector('[style]')) needsResanitize = true;
            if (!hasFormContent && (node.matches('form') || node.querySelector && node.querySelector('form'))) {
              hasFormContent = true;
            }
          }
        });
      });
      if (needsResanitize) {
        // Allow incremental sanitize without undoing previously added classes.
        this.sanitized = false; // Force re-run of sanitizeAndRetheme enhancements.
        this.sanitizeAndRetheme();
      }
      if (hasFormContent) {
        this.removeSpinner();
      }
    });
    observer.observe(this.container, { childList: true, subtree: true });
  };

  TrellisFormHandler.prototype.insertSpinner = function insertSpinner() {
    if (this.spinnerInserted) return;
    this.spinnerInserted = true;
    this.container.setAttribute('data-loading', 'true');
    const overlay = document.createElement('div');
    overlay.className = 'az-media-trellis__spinner-overlay';
    // Bootstrap 5 spinner (relies on theme including Bootstrap assets).
    overlay.innerHTML = '<div class="az-media-trellis__spinner-wrapper d-flex flex-column align-items-center justify-content-center py-4">'
      + '<div class="spinner-border text-primary" role="status" aria-live="polite" aria-label="Loading"></div>'
      + '<div class="visually-hidden">Loading formâ€¦</div>'
      + '</div>';
    this.container.appendChild(overlay);
    // Safety timeout: remove spinner after 15s even if form failed.
    this.spinnerTimeout = setTimeout(() => {
      this.removeSpinner(true);
    }, 15000);
  };

  TrellisFormHandler.prototype.removeSpinner = function removeSpinner(fallback) {
    if (this.spinnerRemoved) return;
    const overlay = this.container.querySelector('.az-media-trellis__spinner-overlay');
    if (!overlay) return;
    if (!fallback) {
      // If we have actual form content keep removing; if not and fallback triggered, leave a subtle message.
      const hasForm = this.container.querySelector('form');
      if (!hasForm && !fallback) return; // wait until form appears
    }
    overlay.remove();
    this.spinnerRemoved = true;
    this.container.removeAttribute('data-loading');
    if (this.spinnerTimeout) clearTimeout(this.spinnerTimeout);
  };
  TrellisFormHandler.prototype.setupEditingMode = function setupEditingMode() {
    const requiredFields = this.container.querySelectorAll('input[aria-required], input.required');
    requiredFields.forEach(field => {
      field.removeAttribute('aria-required');
      field.classList.remove('required');
    });
  };
  TrellisFormHandler.prototype.prefillFields = function prefillFields() {
    Object.entries(this.queryParams).forEach(([name, value]) => {
      const field = this.container.querySelector(`[name="${name}"]`);
      if (field && field.value !== value) {
        field.value = value;
        field.dispatchEvent(new Event('input', {
          bubbles: true
        }));
      }
    });
  };
  Drupal.behaviors.azMediaTrellis = {
    attach(context) {
      const config = drupalSettings.azMediaTrellis || {};
      const queryParams = config.queryParams || {};
      const editing = config.editing || false;
      const blockRemoteCss = !!config.blockRemoteCss;
      if (blockRemoteCss) {
        installCssBlockerOnce();
      }
      const formContainers = context.querySelectorAll('.az-media-trellis:not([data-az-processed])');
      formContainers.forEach(container => {
        container.setAttribute('data-az-processed', 'true');
        const handler = new TrellisFormHandler(container, queryParams, editing);
        handler.init();
        if (blockRemoteCss) {
          loadTrellisScript(container);
        }
      });
    }
  };
})(Drupal, drupalSettings);