<?php

/**
 * @file
 * Contains az_publication.module.
 */

use Drupal\Core\Form\FormStateInterface;
use ADCI\FullNameParser\Parser;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\node\Entity\NodeType;
use Seboettg\CiteProc\CiteProc;
use Drupal\Core\Url;
use Drupal\Core\Link;

/**
 * Implements hook_entity_extra_field_info().
 */
function az_publication_entity_extra_field_info() {
  $extra = [];

  // Check to see if our content type exists.
  $bundle = NodeType::load('az_publication');
  if ($bundle) {
    // Link title pseudo field.
    $extra['node'][$bundle->id()]['display']['az_publication_bibliography'] = [
      'label' => t('Bibliography'),
      'description' => "Bibliographic reference for content",
      'weight' => 50,
      'visible' => FALSE,
    ];
  }

  return $extra;
}

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function az_publication_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {

  // Only if fields suggest a publication.
  if ($entity instanceof FieldableEntityInterface && $entity->hasField('field_az_publication_type') && !empty($entity->field_az_publication_type->value)) {
    if ($display->getComponent('az_publication_bibliography')) {
      // Publicaiton fields to CSL schema mappings.
      $pmap = [
        'field_az_publication_container' => 'container-title',
        'field_az_publication_issue' => 'issue',
        'field_az_publication_volume' => 'volume',
        'field_az_publication_version' => 'version',
        'field_az_publication_location' => 'publisher-place',
        'field_az_publication_page' => 'page',
        'field_az_publication_publisher' => 'publisher',
      ];
      // Author fields to CSL schema mappings.
      $amap = [
        'field_az_author_fname' => 'given',
        'field_az_author_lname' => 'family',
        'field_az_author_drop_particle' => 'dropping-particle',
        'field_az_author_nondrop_particle' => 'non-dropping-particle',
        'field_az_author_suffix' => 'suffix',
        'field_az_author_literal' => 'literal',
      ];
      $blob = new stdClass();
      $blob->title = $entity->getTitle();
      $blob->id = $entity->id();
      $blob->type = $entity->field_az_publication_type->value;
      // Search for style based on view mode.
      $style = $view_mode;
      // Load style if available.
      $style_path = \Drupal::service('extension.list.module')->getPath('az_publication') . DIRECTORY_SEPARATOR . 'citation-style-language' . DIRECTORY_SEPARATOR . 'styles' . DIRECTORY_SEPARATOR . "{$style}.csl";
      $style_info = @file_get_contents($style_path);

      if (!empty($style_info)) {
        // Map authorship information.
        foreach ($pmap as $source => $destination) {
          if (!empty($entity->{$source}->value)) {
            $blob->{$destination} = trim($entity->{$source}->value);
          }
        }
        foreach ($entity->field_az_authors as $item) {
          if (!empty($item->entity)) {
            $author = new stdClass();
            // Only literal name.
            if (!empty($item->entity->field_az_author_literal->value) && empty($item->entity->field_az_author_parse->value)) {
              $author->family = trim($item->entity->field_az_author_literal->value);
            }
            else {
              // Map regular string fields.
              foreach ($amap as $asource => $adestination) {
                if (!empty($item->entity->{$asource}->value)) {
                  $author->{$adestination} = trim($item->entity->{$asource}->value);
                }
              }
            }
            // Special field due to being an URL.
            if (!empty($item->entity->field_az_author_link->uri)) {
              $author->itemlink = $item->entity->field_az_author_link->uri;
            }
            // Special field handling for person reference.
            if (!empty($item->entity->field_az_author_person->entity)) {
              $author->itemlink = $item->entity->field_az_author_person->entity->toUrl()->toString();
            }
            $blob->author[] = $author;
          }
        }
        // Handle publication date if available.
        if (!empty($entity->field_az_publication_date->value)) {
          $date = new stdClass();
          $date->{'date-parts'}[] = explode('-', $entity->field_az_publication_date->value);
          $blob->issued = $date;
        }
        // Handle accessed date if available.
        if (!empty($entity->field_az_accessed_date->value)) {
          $date = new stdClass();
          $date->{'date-parts'}[] = explode('-', $entity->field_az_accessed_date->value);
          $blob->accessed = $date;
        }
        // Handle link field if available.
        if (!empty($entity->field_az_publication_link->uri)) {
          $blob->itemlink = $entity->field_az_publication_link->uri;
        }
        // Handle file link if available.
        if (!empty($entity->field_az_publication_media->entity->field_media_az_document->entity)) {
          $blob->itemlink = $entity->field_az_publication_media->entity->field_media_az_document->entity->createFileUrl(TRUE);
        }

        // Rendering extension for creating links from titles and authors.
        $renderlink = function ($cslItem, $renderedText) {
          // Rendering extension for text with links.
          if (!empty($cslItem->itemlink)) {
            try {
              $url = Url::fromUserInput($cslItem->itemlink);
            }
            catch (InvalidArgumentException $e) {
              $url = Url::fromUri($cslItem->itemlink);
            }
            $link = Link::fromTextAndUrl($renderedText, $url);
            $buildLink = $link->toRenderable();
            $renderedText = \Drupal::service('renderer')->render($buildLink);
            // @todo CiteProc seems to add extra smart quotes to link. Figure out how to escape.
            $renderedText = str_replace('"', '', $renderedText);
          }
          return $renderedText;
        };
        $additionalMarkup = [
          "title" => $renderlink,
          "author" => $renderlink,
          "csl-entry" => function ($cslItem, $renderedText) {
            // Remove citation number tag.
            // In general it's never a good idea to parse html with regex.
            // This works ONLY because the output is a known pattern.
            return preg_replace('#<div class="csl-left-margin">(.*?)</div>#', '', $renderedText);
          },
        ];
        // Set up CSL rendering.
        $citeProc = new CiteProc($style_info, "en-US", $additionalMarkup);
        $biblio = $citeProc->render([$blob], "bibliography");
        $build['az_publication_bibliography'][] = [
          '#type' => 'markup',
          '#markup' => ($biblio),
        ];
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function az_publication_form_auto_entitylabel_settings_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // Provide az_author tokens to the auto_entitylabel settings form.
  if (\Drupal::routeMatch()->getRawParameters()->has('az_author')) {
    $form['auto_entitylabel']['token_help']['#token_types'][] = 'az_author';
  }
}
